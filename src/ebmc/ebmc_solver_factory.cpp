/*******************************************************************\

Module: EBMC's Factory for Word-Level Solvers

Author: Daniel Kroening, dkr@amazon.com

\*******************************************************************/

#include "ebmc_solver_factory.h"

#include <util/unicode.h>

#include <solvers/flattening/boolbv.h>
#include <solvers/prop/prop.h>
#include <solvers/sat/satcheck.h>
#include <solvers/sat/satcheck_cadical.h>
#include <solvers/sat/satcheck_minisat2.h>
#include <solvers/smt2/smt2_dec.h>

#include "ebmc_error.h"
#include "ebmc_version.h"
#include "show_formula_solver.h"

#include <fstream>
#include <iostream>

ebmc_solver_factoryt ebmc_solver_factory(const cmdlinet &cmdline)
{
  if(cmdline.isset("show-formula"))
  {
    if(cmdline.isset("outfile"))
    {
      const std::string filename = cmdline.get_value("outfile");

      return [filename](const namespacet &ns, message_handlert &message_handler)
      {
        std::unique_ptr<std::ofstream> outfile_ptr{
          new std::ofstream(widen_if_needed(filename))};

        if(!*outfile_ptr)
          throw ebmc_errort() << "Failed to open `" << filename << "'";

        messaget message(message_handler);
        message.status() << "Writing formula to `" << filename << "'"
                         << messaget::eom;

        auto dec = std::make_unique<show_formula_solvert>(*outfile_ptr);

        return ebmc_solvert{std::move(outfile_ptr), std::move(dec)};
      };
    }
    else
    {
      return [](const namespacet &, message_handlert &) {
        auto dec = std::make_unique<show_formula_solvert>();
        return ebmc_solvert{std::move(dec)};
      };
    }
  }

  std::optional<smt2_convt::solvert> smt2_solver =
    cmdline.isset("bitwuzla")    ? smt2_convt::solvert::BITWUZLA
    : cmdline.isset("boolector") ? smt2_convt::solvert::BOOLECTOR
    : cmdline.isset("cvc3")      ? smt2_convt::solvert::CVC3
    : cmdline.isset("cvc4")      ? smt2_convt::solvert::CVC4
    : cmdline.isset("cvc5")      ? smt2_convt::solvert::CVC5
    : cmdline.isset("mathsat")   ? smt2_convt::solvert::MATHSAT
    : cmdline.isset("yices")     ? smt2_convt::solvert::YICES
    : cmdline.isset("z3")        ? smt2_convt::solvert::Z3
    : cmdline.isset("smt2")      ? smt2_convt::solvert::GENERIC
                                 : std::optional<smt2_convt::solvert>{};

  if(cmdline.isset("outfile"))
  {
    const std::string filename = cmdline.get_value("outfile");

    if(smt2_solver.has_value())
    {
      return [filename, smt2_solver](
               const namespacet &ns, message_handlert &message_handler)
      {
        std::unique_ptr<std::ofstream> outfile_ptr{
          new std::ofstream(widen_if_needed(filename))};

        if(!*outfile_ptr)
          throw ebmc_errort() << "Failed to open `" << filename << "'";

        messaget message(message_handler);
        message.status() << "Writing SMT2 formula to `" << filename << "'"
                         << messaget::eom;

        auto dec = std::make_unique<smt2_convt>(
          ns,
          "ebmc",
          std::string("Generated by EBMC ") + EBMC_VERSION,
          "QF_AUFBV",
          smt2_solver.value(),
          *outfile_ptr);

        return ebmc_solvert{std::move(outfile_ptr), std::move(dec)};
      };
    }
    else
    {
      // We are given --outfile without an SMT-solver option.
      throw ebmc_errort()
        << "Cannot write to an output file without file format option";
    }
  }

  if(smt2_solver.has_value())
  {
    return
      [smt2_solver](const namespacet &ns, message_handlert &message_handler) {
        if(smt2_solver == smt2_convt::solvert::GENERIC)
        {
          // --smt2 but no --outfile given. Send to std::cout.
          return ebmc_solvert{std::make_unique<smt2_convt>(
            ns,
            "ebmc",
            std::string("Generated by EBMC ") + EBMC_VERSION,
            "QF_AUFBV",
            smt2_solver.value(),
            std::cout)};
        }
        else
        {
          return ebmc_solvert{std::make_unique<smt2_dect>(
            ns,
            "ebmc",
            std::string("Generated by EBMC ") + EBMC_VERSION,
            "QF_AUFBV",
            smt2_solver.value(),
            message_handler)};
        }
      };
  }
  else
  {
    // the 'default' solver
    return [&cmdline](const namespacet &ns, message_handlert &message_handler)
    {
      std::unique_ptr<propt> sat_solver;

      if(cmdline.isset("cadical"))
      {
#ifdef SATCHECK_CADICAL
        sat_solver = std::unique_ptr<propt>(
          new satcheck_cadical_preprocessingt{message_handler});
#else
        throw ebmc_errort() << "support for Cadical not configured";
#endif
      }
      else
      {
        sat_solver = std::unique_ptr<propt>(
          new satcheck_minisat_simplifiert{message_handler});
      }

      messaget message(message_handler);
      message.status() << "Using " << sat_solver->solver_text()
                       << messaget::eom;

      auto dec = std::unique_ptr<stack_decision_proceduret>(
        new boolbvt{ns, *sat_solver, message_handler});

      return ebmc_solvert{std::move(sat_solver), std::move(dec)};
    };
  }
}
